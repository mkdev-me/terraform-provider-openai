package provider

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"time"

	"github.com/hashicorp/terraform-plugin-sdk/v2/diag"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
)

// SubmitToolOutputsRequest represents the request payload for submitting tool outputs.
// It contains a list of tool outputs that were generated during a run step.
type SubmitToolOutputsRequest struct {
	ToolOutputs []ToolOutput `json:"tool_outputs"` // List of tool outputs to submit
}

// ToolOutput represents the output from a single tool execution.
// It contains the tool call ID and the output generated by the tool.
type ToolOutput struct {
	ToolCallID string `json:"tool_call_id"` // ID of the tool call that generated this output
	Output     string `json:"output"`       // Output generated by the tool
}

// resourceOpenAIRunStep defines the schema and CRUD operations for OpenAI run steps.
// This resource allows users to manage individual steps within a run, including
// monitoring step progress, submitting tool outputs, and retrieving step results.
func resourceOpenAIRunStep() *schema.Resource {
	return &schema.Resource{
		CreateContext: resourceOpenAIRunStepCreate,
		ReadContext:   resourceOpenAIRunStepRead,
		DeleteContext: resourceOpenAIRunStepDelete,
		Schema: map[string]*schema.Schema{
			"thread_id": {
				Type:        schema.TypeString,
				Required:    true,
				ForceNew:    true,
				Description: "The ID of the thread that contains the run.",
			},
			"run_id": {
				Type:        schema.TypeString,
				Required:    true,
				ForceNew:    true,
				Description: "The ID of the run that contains the step.",
			},
			"step_id": {
				Type:        schema.TypeString,
				Optional:    true,
				Computed:    true,
				ForceNew:    true,
				Description: "The ID of the specific step to retrieve. If not provided, all steps will be returned.",
			},
			"tool_call_id": {
				Type:        schema.TypeString,
				Optional:    true,
				ForceNew:    true,
				Description: "The ID of the tool call to submit output for.",
			},
			"tool_output": {
				Type:        schema.TypeString,
				Optional:    true,
				ForceNew:    true,
				Description: "The output of the tool call.",
			},
			"step_details": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: "The details of the run step, JSON encoded.",
			},
			"object": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: "The object type, which is always 'thread.run.step'.",
			},
			"created_at": {
				Type:        schema.TypeInt,
				Computed:    true,
				Description: "The timestamp for when the run step was created.",
			},
			"type": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: "The type of the run step.",
			},
			"status": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: "The status of the run step.",
			},
			"completion_window": {
				Type:        schema.TypeInt,
				Optional:    true,
				ForceNew:    true,
				Description: "The maximum amount of time to wait for the step to complete, in seconds. If not provided, it will not wait for completion.",
			},
		},
	}
}

// resourceOpenAIRunStepCreate initiates a new run step or submits tool outputs.
// It processes the step configuration, handles tool output submission if required,
// and monitors the step's progress until completion.
func resourceOpenAIRunStepCreate(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics {
	client := m.(*OpenAIClient)

	// Get the input parameters from the schema
	threadID := d.Get("thread_id").(string)
	runID := d.Get("run_id").(string)
	stepIDInput, hasStepID := d.GetOk("step_id")
	toolCallID, hasToolCallID := d.GetOk("tool_call_id")
	toolOutput, hasToolOutput := d.GetOk("tool_output")

	// Si se proporciona un ID de step, recuperar ese step específico
	if hasStepID {
		stepID := stepIDInput.(string)

		// Prepare the HTTP request
		url := fmt.Sprintf("%s/threads/%s/runs/%s/steps/%s", client.APIURL, threadID, runID, stepID)
		req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
		if err != nil {
			return diag.FromErr(fmt.Errorf("error creating request: %v", err))
		}

		// Set headers
		req.Header.Set("Authorization", "Bearer "+client.APIKey)
		req.Header.Set("OpenAI-Beta", "assistants=v2")

		// Add Organization ID if present
		if client.OrganizationID != "" {
			req.Header.Set("OpenAI-Organization", client.OrganizationID)
		}

		// Make the request
		resp, err := http.DefaultClient.Do(req)
		if err != nil {
			return diag.FromErr(fmt.Errorf("error making request: %v", err))
		}
		defer resp.Body.Close()

		// Read the response
		respBody, err := io.ReadAll(resp.Body)
		if err != nil {
			return diag.FromErr(fmt.Errorf("error reading response: %v", err))
		}

		// Check if there was an error
		if resp.StatusCode != http.StatusOK {
			var errorResponse ErrorResponse
			if err := json.Unmarshal(respBody, &errorResponse); err != nil {
				return diag.FromErr(fmt.Errorf("error parsing error response: %v, status code: %d, body: %s",
					err, resp.StatusCode, string(respBody)))
			}
			return diag.FromErr(fmt.Errorf("error retrieving run step: %s - %s",
				errorResponse.Error.Type, errorResponse.Error.Message))
		}

		// Parse the response
		var stepResponse RunStepResponse
		if err := json.Unmarshal(respBody, &stepResponse); err != nil {
			return diag.FromErr(fmt.Errorf("error parsing response: %v", err))
		}

		// Set the resource ID
		d.SetId(stepResponse.ID)

		// Set the step attributes
		if err := d.Set("object", stepResponse.Object); err != nil {
			return diag.FromErr(fmt.Errorf("failed to set object: %v", err))
		}
		if err := d.Set("created_at", stepResponse.CreatedAt); err != nil {
			return diag.FromErr(fmt.Errorf("failed to set created_at: %v", err))
		}
		if err := d.Set("type", stepResponse.Type); err != nil {
			return diag.FromErr(fmt.Errorf("failed to set type: %v", err))
		}
		if err := d.Set("status", stepResponse.Status); err != nil {
			return diag.FromErr(fmt.Errorf("failed to set status: %v", err))
		}

		// Convert details to JSON
		detailsJSON, err := json.Marshal(stepResponse.Details)
		if err == nil {
			if err := d.Set("step_details", string(detailsJSON)); err != nil {
				return diag.FromErr(fmt.Errorf("failed to set step_details: %v", err))
			}
		} else {
			if err := d.Set("step_details", "{}"); err != nil {
				return diag.FromErr(fmt.Errorf("failed to set step_details: %v", err))
			}
		}

	} else if hasToolCallID && hasToolOutput {
		// Si se proporcionan tool_call_id y tool_output, enviar una respuesta de herramienta
		toolCallIDStr := toolCallID.(string)
		toolOutputStr := toolOutput.(string)

		// Prepare the request to send the tool output
		request := &SubmitToolOutputsRequest{
			ToolOutputs: []ToolOutput{
				{
					ToolCallID: toolCallIDStr,
					Output:     toolOutputStr,
				},
			},
		}

		// Prepare the HTTP request
		url := fmt.Sprintf("%s/threads/%s/runs/%s/submit_tool_outputs", client.APIURL, threadID, runID)
		reqBody, err := json.Marshal(request)
		if err != nil {
			return diag.FromErr(fmt.Errorf("error serializing tool outputs request: %v", err))
		}

		req, err := http.NewRequestWithContext(ctx, "POST", url, bytes.NewReader(reqBody))
		if err != nil {
			return diag.FromErr(fmt.Errorf("error creating request: %v", err))
		}

		// Set headers
		req.Header.Set("Content-Type", "application/json")
		req.Header.Set("Authorization", "Bearer "+client.APIKey)
		req.Header.Set("OpenAI-Beta", "assistants=v2")

		// Add Organization ID if present
		if client.OrganizationID != "" {
			req.Header.Set("OpenAI-Organization", client.OrganizationID)
		}

		// Make the request
		resp, err := http.DefaultClient.Do(req)
		if err != nil {
			return diag.FromErr(fmt.Errorf("error making request: %v", err))
		}
		defer resp.Body.Close()

		// Read the response
		respBody, err := io.ReadAll(resp.Body)
		if err != nil {
			return diag.FromErr(fmt.Errorf("error reading response: %v", err))
		}

		// Check if there was an error
		if resp.StatusCode != http.StatusOK {
			var errorResponse ErrorResponse
			if err := json.Unmarshal(respBody, &errorResponse); err != nil {
				return diag.FromErr(fmt.Errorf("error parsing error response: %v, status code: %d, body: %s",
					err, resp.StatusCode, string(respBody)))
			}
			return diag.FromErr(fmt.Errorf("error submitting tool outputs: %s - %s",
				errorResponse.Error.Type, errorResponse.Error.Message))
		}

		// Parse the response
		var runResponse RunResponse
		if err := json.Unmarshal(respBody, &runResponse); err != nil {
			return diag.FromErr(fmt.Errorf("error parsing response: %v", err))
		}

		// Generar un ID único para este recurso
		toolOutputID := fmt.Sprintf("tool-output-%d", time.Now().UnixNano())
		d.SetId(toolOutputID)

		// Esperar a que el run complete si se especificó un completion_window
		if completionWindow, ok := d.GetOk("completion_window"); ok && completionWindow.(int) > 0 {
			timeoutSeconds := completionWindow.(int)
			pollInterval := 2 // Intervalo de polling en segundos

			// Calcular el tiempo máximo de espera
			endTime := time.Now().Add(time.Duration(timeoutSeconds) * time.Second)

			for time.Now().Before(endTime) {
				// Get the current steps of the run
				stepsURL := fmt.Sprintf("%s/threads/%s/runs/%s/steps", client.APIURL, threadID, runID)
				stepsReq, err := http.NewRequestWithContext(ctx, "GET", stepsURL, nil)
				if err != nil {
					return diag.FromErr(fmt.Errorf("error creating steps request: %v", err))
				}

				stepsReq.Header.Set("Authorization", "Bearer "+client.APIKey)
				stepsReq.Header.Set("OpenAI-Beta", "assistants=v2")

				if client.OrganizationID != "" {
					stepsReq.Header.Set("OpenAI-Organization", client.OrganizationID)
				}

				stepsResp, err := http.DefaultClient.Do(stepsReq)
				if err != nil {
					return diag.FromErr(fmt.Errorf("error making steps request: %v", err))
				}

				stepsBody, err := io.ReadAll(stepsResp.Body)
				stepsResp.Body.Close()

				if err != nil {
					return diag.FromErr(fmt.Errorf("error reading steps response: %v", err))
				}

				if stepsResp.StatusCode != http.StatusOK {
					var errorResponse ErrorResponse
					if err := json.Unmarshal(stepsBody, &errorResponse); err != nil {
						return diag.FromErr(fmt.Errorf("error parsing error response: %v, status code: %d, body: %s",
							err, stepsResp.StatusCode, string(stepsBody)))
					}
					return diag.FromErr(fmt.Errorf("error getting run steps: %s - %s",
						errorResponse.Error.Type, errorResponse.Error.Message))
				}

				var stepsResponse ListRunStepsResponse
				if err := json.Unmarshal(stepsBody, &stepsResponse); err != nil {
					return diag.FromErr(fmt.Errorf("error parsing steps response: %v", err))
				}

				// Buscar el step de tipo 'tool_calls' más reciente
				var latestToolStep *RunStepResponse
				for i := range stepsResponse.Data {
					step := &stepsResponse.Data[i]
					if step.Type == "tool_calls" && step.Status == "completed" {
						latestToolStep = step
						break
					}
				}

				if latestToolStep != nil {
					// Si encontramos un step de tool_calls completado, actualizamos el estado
					if err := d.Set("step_id", latestToolStep.ID); err != nil {
						return diag.FromErr(fmt.Errorf("failed to set step_id: %v", err))
					}
					if err := d.Set("object", latestToolStep.Object); err != nil {
						return diag.FromErr(fmt.Errorf("failed to set object: %v", err))
					}
					if err := d.Set("created_at", latestToolStep.CreatedAt); err != nil {
						return diag.FromErr(fmt.Errorf("failed to set created_at: %v", err))
					}
					if err := d.Set("type", latestToolStep.Type); err != nil {
						return diag.FromErr(fmt.Errorf("failed to set type: %v", err))
					}
					if err := d.Set("status", latestToolStep.Status); err != nil {
						return diag.FromErr(fmt.Errorf("failed to set status: %v", err))
					}

					// Convert details to JSON
					detailsJSON, err := json.Marshal(latestToolStep.Details)
					if err == nil {
						if err := d.Set("step_details", string(detailsJSON)); err != nil {
							return diag.FromErr(fmt.Errorf("failed to set step_details: %v", err))
						}
					} else {
						if err := d.Set("step_details", "{}"); err != nil {
							return diag.FromErr(fmt.Errorf("failed to set step_details: %v", err))
						}
					}
					break
				}

				// Check if the run has completed or failed
				runStatusURL := fmt.Sprintf("%s/threads/%s/runs/%s", client.APIURL, threadID, runID)
				runStatusReq, err := http.NewRequestWithContext(ctx, "GET", runStatusURL, nil)
				if err != nil {
					return diag.FromErr(fmt.Errorf("error creating run status request: %v", err))
				}

				runStatusReq.Header.Set("Authorization", "Bearer "+client.APIKey)
				runStatusReq.Header.Set("OpenAI-Beta", "assistants=v2")

				if client.OrganizationID != "" {
					runStatusReq.Header.Set("OpenAI-Organization", client.OrganizationID)
				}

				runStatusResp, err := http.DefaultClient.Do(runStatusReq)
				if err != nil {
					return diag.FromErr(fmt.Errorf("error making run status request: %v", err))
				}

				runStatusBody, err := io.ReadAll(runStatusResp.Body)
				runStatusResp.Body.Close()

				if err != nil {
					return diag.FromErr(fmt.Errorf("error reading run status response: %v", err))
				}

				var statusRunResponse RunResponse
				if err := json.Unmarshal(runStatusBody, &statusRunResponse); err != nil {
					return diag.FromErr(fmt.Errorf("error parsing run status response: %v", err))
				}

				if statusRunResponse.Status == "completed" || statusRunResponse.Status == "failed" ||
					statusRunResponse.Status == "cancelled" || statusRunResponse.Status == "expired" {
					break
				}

				// Esperar antes de la siguiente comprobación
				time.Sleep(time.Duration(pollInterval) * time.Second)
			}
		}

	} else {
		// Si no se proporciona un ID de step ni una salida de herramienta, listar todos los steps y tomar el primero
		// Prepare the HTTP request
		url := fmt.Sprintf("%s/threads/%s/runs/%s/steps", client.APIURL, threadID, runID)
		req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
		if err != nil {
			return diag.FromErr(fmt.Errorf("error creating request: %v", err))
		}

		// Set headers
		req.Header.Set("Authorization", "Bearer "+client.APIKey)
		req.Header.Set("OpenAI-Beta", "assistants=v2")

		// Add Organization ID if present
		if client.OrganizationID != "" {
			req.Header.Set("OpenAI-Organization", client.OrganizationID)
		}

		// Make the request
		resp, err := http.DefaultClient.Do(req)
		if err != nil {
			return diag.FromErr(fmt.Errorf("error making request: %v", err))
		}
		defer resp.Body.Close()

		// Read the response
		respBody, err := io.ReadAll(resp.Body)
		if err != nil {
			return diag.FromErr(fmt.Errorf("error reading response: %v", err))
		}

		// Check if there was an error
		if resp.StatusCode != http.StatusOK {
			var errorResponse ErrorResponse
			if err := json.Unmarshal(respBody, &errorResponse); err != nil {
				return diag.FromErr(fmt.Errorf("error parsing error response: %v, status code: %d, body: %s",
					err, resp.StatusCode, string(respBody)))
			}
			return diag.FromErr(fmt.Errorf("error listing run steps: %s - %s",
				errorResponse.Error.Type, errorResponse.Error.Message))
		}

		// Parse the response
		var stepsResponse ListRunStepsResponse
		if err := json.Unmarshal(respBody, &stepsResponse); err != nil {
			return diag.FromErr(fmt.Errorf("error parsing response: %v", err))
		}

		// Check that there are steps
		if len(stepsResponse.Data) == 0 {
			return diag.FromErr(fmt.Errorf("no steps found for run %s", runID))
		}

		// Tomar el primer paso
		firstStep := stepsResponse.Data[0]

		// Set the resource ID
		d.SetId(firstStep.ID)
		if err := d.Set("step_id", firstStep.ID); err != nil {
			return diag.FromErr(fmt.Errorf("failed to set step_id: %v", err))
		}

		// Set other attributes
		if err := d.Set("object", firstStep.Object); err != nil {
			return diag.FromErr(fmt.Errorf("failed to set object: %v", err))
		}
		if err := d.Set("created_at", firstStep.CreatedAt); err != nil {
			return diag.FromErr(fmt.Errorf("failed to set created_at: %v", err))
		}
		if err := d.Set("type", firstStep.Type); err != nil {
			return diag.FromErr(fmt.Errorf("failed to set type: %v", err))
		}
		if err := d.Set("status", firstStep.Status); err != nil {
			return diag.FromErr(fmt.Errorf("failed to set status: %v", err))
		}

		// Convert details to JSON
		detailsJSON, err := json.Marshal(firstStep.Details)
		if err == nil {
			if err := d.Set("step_details", string(detailsJSON)); err != nil {
				return diag.FromErr(fmt.Errorf("failed to set step_details: %v", err))
			}
		} else {
			if err := d.Set("step_details", "{}"); err != nil {
				return diag.FromErr(fmt.Errorf("failed to set step_details: %v", err))
			}
		}
	}

	return diag.Diagnostics{}
}

// resourceOpenAIRunStepRead retrieves the current state of a run step.
// It fetches the latest step information from the API and updates the Terraform state
// with current status, tool outputs, and step results.
func resourceOpenAIRunStepRead(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics {
	client := m.(*OpenAIClient)

	// Get the necessary parameters
	threadID := d.Get("thread_id").(string)
	runID := d.Get("run_id").(string)
	stepID := d.Id()

	// Prepare the HTTP request
	url := fmt.Sprintf("%s/threads/%s/runs/%s/steps/%s", client.APIURL, threadID, runID, stepID)
	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return diag.FromErr(fmt.Errorf("error creating request: %v", err))
	}

	// Set headers
	req.Header.Set("Authorization", "Bearer "+client.APIKey)
	req.Header.Set("OpenAI-Beta", "assistants=v2")

	// Add Organization ID if present
	if client.OrganizationID != "" {
		req.Header.Set("OpenAI-Organization", client.OrganizationID)
	}

	// Make the request
	resp, err := http.DefaultClient.Do(req)
	if err != nil {
		return diag.FromErr(fmt.Errorf("error making request: %v", err))
	}
	defer resp.Body.Close()

	// Check if the step exists
	if resp.StatusCode == http.StatusNotFound {
		d.SetId("")
		return diag.Diagnostics{}
	}

	// Read the response
	respBody, err := io.ReadAll(resp.Body)
	if err != nil {
		return diag.FromErr(fmt.Errorf("error reading response: %v", err))
	}

	// Check if there was an error
	if resp.StatusCode != http.StatusOK {
		var errorResponse ErrorResponse
		if err := json.Unmarshal(respBody, &errorResponse); err != nil {
			return diag.FromErr(fmt.Errorf("error parsing error response: %v, status code: %d, body: %s",
				err, resp.StatusCode, string(respBody)))
		}
		return diag.FromErr(fmt.Errorf("error reading run step: %s - %s",
			errorResponse.Error.Type, errorResponse.Error.Message))
	}

	// Parse the response
	var stepResponse RunStepResponse
	if err := json.Unmarshal(respBody, &stepResponse); err != nil {
		return diag.FromErr(fmt.Errorf("error parsing response: %v", err))
	}

	// Update the step attributes
	if err := d.Set("object", stepResponse.Object); err != nil {
		return diag.FromErr(fmt.Errorf("failed to set object: %v", err))
	}
	if err := d.Set("created_at", stepResponse.CreatedAt); err != nil {
		return diag.FromErr(fmt.Errorf("failed to set created_at: %v", err))
	}
	if err := d.Set("type", stepResponse.Type); err != nil {
		return diag.FromErr(fmt.Errorf("failed to set type: %v", err))
	}
	if err := d.Set("status", stepResponse.Status); err != nil {
		return diag.FromErr(fmt.Errorf("failed to set status: %v", err))
	}

	// Convert details to JSON
	detailsJSON, err := json.Marshal(stepResponse.Details)
	if err == nil {
		if err := d.Set("step_details", string(detailsJSON)); err != nil {
			return diag.FromErr(fmt.Errorf("failed to set step_details: %v", err))
		}
	} else {
		if err := d.Set("step_details", "{}"); err != nil {
			return diag.FromErr(fmt.Errorf("failed to set step_details: %v", err))
		}
	}

	return diag.Diagnostics{}
}

// resourceOpenAIRunStepDelete removes a run step.
// Note: Run steps cannot be deleted through the API.
// This function only removes the resource from the Terraform state.
func resourceOpenAIRunStepDelete(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics {
	// No es posible eliminar un step, así que simplemente limpiamos el estado
	d.SetId("")
	return nil
}
