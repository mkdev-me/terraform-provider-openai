package provider

import (
	"context"
	"encoding/json"
	"fmt"
	"time"

	"github.com/hashicorp/terraform-plugin-sdk/v2/diag"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/validation"
)

// ChatCompletionsResponse represents the API response for listing chat completions.
type ChatCompletionsResponse struct {
	Object  string                   `json:"object"`
	Data    []ChatCompletionResponse `json:"data"`
	HasMore bool                     `json:"has_more"`
}

// dataSourceOpenAIChatCompletions returns a schema.Resource that represents a data source for listing OpenAI chat completions.
// This data source allows users to retrieve a list of chat completions with filtering options.
func dataSourceOpenAIChatCompletions() *schema.Resource {
	return &schema.Resource{
		ReadContext: dataSourceOpenAIChatCompletionsRead,
		Schema: map[string]*schema.Schema{
			"after": {
				Type:        schema.TypeString,
				Optional:    true,
				Description: "Identifier for the last chat completion from the previous pagination request",
			},
			"limit": {
				Type:         schema.TypeInt,
				Optional:     true,
				Default:      20,
				ValidateFunc: validation.IntBetween(1, 100),
				Description:  "Number of chat completions to retrieve (defaults to 20, max 100)",
			},
			"metadata": {
				Type:        schema.TypeMap,
				Optional:    true,
				Description: "A list of metadata keys to filter the chat completions by",
				Elem: &schema.Schema{
					Type: schema.TypeString,
				},
			},
			"model": {
				Type:        schema.TypeString,
				Optional:    true,
				Description: "The model used to generate the chat completions",
			},
			"order": {
				Type:         schema.TypeString,
				Optional:     true,
				Default:      "asc",
				ValidateFunc: validation.StringInSlice([]string{"asc", "desc"}, false),
				Description:  "Sort order for chat completions by timestamp. Use 'asc' for ascending order or 'desc' for descending order. Defaults to 'asc'.",
			},
			"chat_completions": {
				Type:        schema.TypeList,
				Computed:    true,
				Description: "The list of chat completions",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"id": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: "The ID of the chat completion",
						},
						"object": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: "The object type, which is always 'chat.completion'",
						},
						"created": {
							Type:        schema.TypeInt,
							Computed:    true,
							Description: "The Unix timestamp (in seconds) of when the chat completion was created",
						},
						"model": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: "The model used for the chat completion",
						},
						"choices": {
							Type:        schema.TypeList,
							Computed:    true,
							Description: "The list of chat completion choices the model generated",
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"index": {
										Type:        schema.TypeInt,
										Computed:    true,
										Description: "The index of the choice in the list of choices",
									},
									"message": {
										Type:        schema.TypeList,
										Computed:    true,
										Description: "The message generated by the model",
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"role": {
													Type:        schema.TypeString,
													Computed:    true,
													Description: "The role of the message author",
												},
												"content": {
													Type:        schema.TypeString,
													Computed:    true,
													Description: "The content of the message",
												},
												"function_call": {
													Type:        schema.TypeList,
													Computed:    true,
													Description: "The function call generated by the model",
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{
															"name": {
																Type:        schema.TypeString,
																Computed:    true,
																Description: "The name of the function to call",
															},
															"arguments": {
																Type:        schema.TypeString,
																Computed:    true,
																Description: "The arguments to call the function with, as a JSON string",
															},
														},
													},
												},
											},
										},
									},
									"finish_reason": {
										Type:        schema.TypeString,
										Computed:    true,
										Description: "The reason the model stopped generating text",
									},
								},
							},
						},
						"usage": {
							Type:        schema.TypeMap,
							Computed:    true,
							Description: "Usage statistics for the chat completion request",
							Elem: &schema.Schema{
								Type: schema.TypeInt,
							},
						},
					},
				},
			},
			"has_more": {
				Type:        schema.TypeBool,
				Computed:    true,
				Description: "Whether there are more chat completions to retrieve",
			},
		},
	}
}

// dataSourceOpenAIChatCompletionsRead handles the read operation for the OpenAI chat completions data source.
// It retrieves a list of chat completions from the OpenAI API with filtering options.
func dataSourceOpenAIChatCompletionsRead(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics {
	client, err := GetOpenAIClient(m)
	if err != nil {
		return diag.FromErr(fmt.Errorf("failed to get OpenAI client: %s", err))
	}

	url := "/v1/chat/completions"

	// Add query parameters if provided
	params := make(map[string]string)
	if limit, ok := d.GetOk("limit"); ok {
		params["limit"] = fmt.Sprintf("%d", limit.(int))
	}
	if order, ok := d.GetOk("order"); ok {
		params["order"] = order.(string)
	}
	if after, ok := d.GetOk("after"); ok {
		params["after"] = after.(string)
	}
	if before, ok := d.GetOk("before"); ok {
		params["before"] = before.(string)
	}

	// Add metadata filtering
	if metadata, ok := d.GetOk("metadata"); ok {
		metadataMap := metadata.(map[string]interface{})
		for k, v := range metadataMap {
			params[fmt.Sprintf("metadata[%s]", k)] = v.(string)
		}
	}

	// Add query parameters to the URL
	if len(params) > 0 {
		url += "?"
		for key, value := range params {
			url += fmt.Sprintf("%s=%s&", key, value)
		}
		url = url[:len(url)-1] // Remove trailing &
	}

	respBody, err := client.DoRequest("GET", url, nil)
	if err != nil {
		// Instead of failing, just return an empty list with a warning
		d.SetId(fmt.Sprintf("chat_completions_%d", time.Now().Unix()))
		d.Set("has_more", false)
		// Set empty chat_completions array
		if err := d.Set("chat_completions", []map[string]interface{}{}); err != nil {
			return diag.FromErr(err)
		}
		return diag.Diagnostics{
			diag.Diagnostic{
				Severity: diag.Warning,
				Summary:  "Error retrieving chat completions",
				Detail:   fmt.Sprintf("Could not retrieve chat completions: %s. Returning empty list.", err),
			},
		}
	}

	var response ChatCompletionsResponse
	if err := json.Unmarshal(respBody, &response); err != nil {
		return diag.FromErr(fmt.Errorf("error parsing chat completions response: %s", err))
	}

	d.SetId(fmt.Sprintf("chat_completions_%d", time.Now().Unix()))
	d.Set("has_more", response.HasMore)

	// Process chat completions
	if len(response.Data) > 0 {
		chatCompletions := make([]map[string]interface{}, 0, len(response.Data))
		for _, completion := range response.Data {
			chatCompletion := map[string]interface{}{
				"id":      completion.ID,
				"object":  completion.Object,
				"created": completion.Created,
				"model":   completion.Model,
			}

			// Process choices
			if len(completion.Choices) > 0 {
				choices := make([]map[string]interface{}, 0, len(completion.Choices))
				for _, choice := range completion.Choices {
					choiceMap := map[string]interface{}{
						"index":         choice.Index,
						"finish_reason": choice.FinishReason,
					}

					// Process the message
					if choice.Message.Role != "" {
						message := map[string]interface{}{
							"role":    choice.Message.Role,
							"content": choice.Message.Content,
						}

						if choice.Message.Name != "" {
							message["name"] = choice.Message.Name
						}

						// Add function_call if present
						if choice.Message.FunctionCall != nil {
							functionCall := []map[string]interface{}{
								{
									"name":      choice.Message.FunctionCall.Name,
									"arguments": choice.Message.FunctionCall.Arguments,
								},
							}
							message["function_call"] = functionCall
						}

						choiceMap["message"] = []map[string]interface{}{message}
					}

					choices = append(choices, choiceMap)
				}
				chatCompletion["choices"] = choices
			}

			// Process usage
			if completion.Usage.TotalTokens > 0 {
				usage := map[string]int{
					"prompt_tokens":     completion.Usage.PromptTokens,
					"completion_tokens": completion.Usage.CompletionTokens,
					"total_tokens":      completion.Usage.TotalTokens,
				}
				chatCompletion["usage"] = usage
			}

			chatCompletions = append(chatCompletions, chatCompletion)
		}

		if err := d.Set("chat_completions", chatCompletions); err != nil {
			return diag.FromErr(err)
		}
	} else {
		// Set empty chat_completions array for consistency
		if err := d.Set("chat_completions", []map[string]interface{}{}); err != nil {
			return diag.FromErr(err)
		}
	}

	return diag.Diagnostics{}
}
