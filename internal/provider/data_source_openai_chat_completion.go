package provider

import (
	"context"
	"encoding/json"
	"fmt"
	"strings"

	"github.com/hashicorp/terraform-plugin-sdk/v2/diag"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
)

// ChatToolCall represents a tool call generated by the model.
// It contains the ID, type, and function details.
type ChatToolCall struct {
	ID       string           `json:"id"`       // The ID of the tool call
	Type     string           `json:"type"`     // The type of tool call
	Function *ChatFunctionDef `json:"function"` // The function details
}

// ChatFunctionDef represents a function definition in a tool call.
// It contains the function name and arguments.
type ChatFunctionDef struct {
	Name      string `json:"name"`      // Name of the function to call
	Arguments string `json:"arguments"` // JSON string containing function arguments
}

// For our data source, we need to extend the ChatCompletionMessage to include tool calls
type DataSourceChatCompletionMessage struct {
	Role         string            `json:"role"`                    // Role of the message sender (system, user, assistant)
	Content      string            `json:"content"`                 // Content of the message
	FunctionCall *ChatFunctionCall `json:"function_call,omitempty"` // Optional function call
	Name         string            `json:"name,omitempty"`          // Optional name of the message sender
	ToolCalls    []ChatToolCall    `json:"tool_calls,omitempty"`    // Optional tool calls
}

// DataSourceChatCompletionChoice extends ChatCompletionChoice with our custom message type
type DataSourceChatCompletionChoice struct {
	Index        int                             `json:"index"`         // Index of the choice in the list
	Message      DataSourceChatCompletionMessage `json:"message"`       // The generated message
	FinishReason string                          `json:"finish_reason"` // Reason why the completion finished
}

// DataSourceChatCompletionResponse extends ChatCompletionResponse with our custom choice type
type DataSourceChatCompletionResponse struct {
	ID      string                           `json:"id"`      // Unique identifier for the completion
	Object  string                           `json:"object"`  // Type of object (e.g., "chat.completion")
	Created int                              `json:"created"` // Unix timestamp when the completion was created
	Model   string                           `json:"model"`   // Model used for the completion
	Choices []DataSourceChatCompletionChoice `json:"choices"` // List of possible completions
	Usage   ChatCompletionUsage              `json:"usage"`   // Token usage statistics
}

// dataSourceOpenAIChatCompletion returns a schema.Resource that represents a data source for an OpenAI chat completion.
// This data source allows users to retrieve information about a specific chat completion by ID.
func dataSourceOpenAIChatCompletion() *schema.Resource {
	return &schema.Resource{
		ReadContext: dataSourceOpenAIChatCompletionRead,
		Schema: map[string]*schema.Schema{
			"completion_id": {
				Type:        schema.TypeString,
				Required:    true,
				Description: "The ID of the chat completion to retrieve (format: chatcmpl-xxx)",
			},
			"api_key": {
				Type:        schema.TypeString,
				Optional:    true,
				Sensitive:   true,
				Description: "API key for authentication. If not provided, the provider's default API key will be used.",
			},
			"id": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: "The ID of the chat completion",
			},
			"created": {
				Type:        schema.TypeInt,
				Computed:    true,
				Description: "The Unix timestamp (in seconds) of when the chat completion was created",
			},
			"object": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: "The object type, which is always 'chat.completion'",
			},
			"model": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: "The model used for the chat completion",
			},
			"choices": {
				Type:        schema.TypeList,
				Computed:    true,
				Description: "The list of chat completion choices the model generated",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"index": {
							Type:        schema.TypeInt,
							Computed:    true,
							Description: "The index of the choice in the list of choices",
						},
						"message": {
							Type:        schema.TypeList,
							Computed:    true,
							Description: "The message generated by the model",
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"role": {
										Type:        schema.TypeString,
										Computed:    true,
										Description: "The role of the message author",
									},
									"content": {
										Type:        schema.TypeString,
										Computed:    true,
										Description: "The content of the message",
									},
									"function_call": {
										Type:        schema.TypeList,
										Computed:    true,
										Description: "The function call generated by the model",
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"name": {
													Type:        schema.TypeString,
													Computed:    true,
													Description: "The name of the function to call",
												},
												"arguments": {
													Type:        schema.TypeString,
													Computed:    true,
													Description: "The arguments to call the function with, as a JSON string",
												},
											},
										},
									},
									"tool_calls": {
										Type:        schema.TypeList,
										Computed:    true,
										Description: "The tool calls generated by the model",
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"id": {
													Type:        schema.TypeString,
													Computed:    true,
													Description: "The ID of the tool call",
												},
												"type": {
													Type:        schema.TypeString,
													Computed:    true,
													Description: "The type of tool call",
												},
												"function": {
													Type:        schema.TypeList,
													Computed:    true,
													Description: "The function details",
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{
															"name": {
																Type:        schema.TypeString,
																Computed:    true,
																Description: "The name of the function to call",
															},
															"arguments": {
																Type:        schema.TypeString,
																Computed:    true,
																Description: "The arguments to call the function with, as a JSON string",
															},
														},
													},
												},
											},
										},
									},
								},
							},
						},
						"finish_reason": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: "The reason the model stopped generating text",
						},
					},
				},
			},
			"usage": {
				Type:        schema.TypeMap,
				Computed:    true,
				Description: "Usage statistics for the chat completion request",
				Elem: &schema.Schema{
					Type: schema.TypeInt,
				},
			},
		},
	}
}

// dataSourceOpenAIChatCompletionRead handles the read operation for the OpenAI chat completion data source.
// It retrieves information about a specific chat completion from the OpenAI API.
func dataSourceOpenAIChatCompletionRead(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics {
	client, err := GetOpenAIClient(m)
	if err != nil {
		return diag.FromErr(fmt.Errorf("failed to get OpenAI client: %s", err))
	}

	completionID := d.Get("completion_id").(string)
	url := fmt.Sprintf("/v1/chat/completions/%s", completionID)

	respBody, err := client.DoRequest("GET", url, nil)
	if err != nil {
		// Check if it's a not found error, and handle gracefully
		if strings.Contains(err.Error(), "not found") {
			// Set ID to the requested ID to prevent Terraform from failing
			d.SetId(completionID)
			return diag.Diagnostics{
				diag.Diagnostic{
					Severity: diag.Warning,
					Summary:  "Chat completion not found",
					Detail:   fmt.Sprintf("Chat completion with ID '%s' could not be found. This may be because it has expired or was deleted from the OpenAI Chat Completions Store.", completionID),
				},
			}
		}
		return diag.Errorf("Error retrieving chat completion with ID '%s': %s", completionID, err)
	}

	var completion DataSourceChatCompletionResponse
	if err := json.Unmarshal(respBody, &completion); err != nil {
		return diag.FromErr(fmt.Errorf("error parsing chat completion response: %s", err))
	}

	d.SetId(completion.ID)
	d.Set("id", completion.ID)
	d.Set("created", completion.Created)
	d.Set("object", completion.Object)
	d.Set("model", completion.Model)

	// Process choices
	if len(completion.Choices) > 0 {
		choices := make([]map[string]interface{}, 0, len(completion.Choices))

		for _, choice := range completion.Choices {
			choiceMap := map[string]interface{}{
				"index":         choice.Index,
				"finish_reason": choice.FinishReason,
			}

			// Process the message
			message := map[string]interface{}{
				"role":    choice.Message.Role,
				"content": choice.Message.Content,
			}

			if choice.Message.Name != "" {
				message["name"] = choice.Message.Name
			}

			// Add function_call if present
			if choice.Message.FunctionCall != nil {
				functionCall := []map[string]interface{}{
					{
						"name":      choice.Message.FunctionCall.Name,
						"arguments": choice.Message.FunctionCall.Arguments,
					},
				}
				message["function_call"] = functionCall
			}

			// Add tool_calls if present
			if len(choice.Message.ToolCalls) > 0 {
				toolCalls := make([]map[string]interface{}, 0, len(choice.Message.ToolCalls))
				for _, toolCall := range choice.Message.ToolCalls {
					toolCallMap := map[string]interface{}{
						"id":   toolCall.ID,
						"type": toolCall.Type,
					}

					if toolCall.Function != nil {
						toolCallMap["function"] = []map[string]interface{}{
							{
								"name":      toolCall.Function.Name,
								"arguments": toolCall.Function.Arguments,
							},
						}
					}
					toolCalls = append(toolCalls, toolCallMap)
				}
				message["tool_calls"] = toolCalls
			}

			choiceMap["message"] = []map[string]interface{}{message}
			choices = append(choices, choiceMap)
		}

		if err := d.Set("choices", choices); err != nil {
			return diag.FromErr(err)
		}
	}

	// Set usage statistics
	usage := map[string]int{
		"prompt_tokens":     completion.Usage.PromptTokens,
		"completion_tokens": completion.Usage.CompletionTokens,
		"total_tokens":      completion.Usage.TotalTokens,
	}
	if err := d.Set("usage", usage); err != nil {
		return diag.FromErr(err)
	}

	return diag.Diagnostics{}
}
